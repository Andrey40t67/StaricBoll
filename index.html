<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –®—É—Ç–µ—Ä –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #222;
            color: white;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            background-color: rgba(51, 51, 51, 0.7);
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        #ammo {
            margin-top: 10px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            text-align: center;
            line-height: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        #game-over, #level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 15px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #3e8e41;
        }
        #device-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 1.2s ease-out;
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        #device-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: titlePulse 2s infinite;
            letter-spacing: 2px;
        }
        @keyframes titlePulse {
            0% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(76, 175, 80, 0.6); }
            100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        }
        .device-buttons {
            display: flex;
            gap: 40px;
            animation: slideUp 0.8s ease-out 0.4s both;
        }
        @keyframes slideUp {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .device-button {
            background: linear-gradient(145deg, #4CAF50, #3e8e41);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 22px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 
                        0 0 0 rgba(76, 175, 80, 0.4);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .device-button:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 60%);
            transform: rotate(45deg);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .device-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(76, 175, 80, 0.6);
            background: linear-gradient(145deg, #5dbd61, #4CAF50);
        }
        .device-button:hover:before {
            opacity: 1;
            animation: shine 1.5s infinite;
        }
        @keyframes shine {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }
        .device-button:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            pointer-events: none;
        }
        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        .action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        .action-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
        }
        .look-area {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }
        #reload-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>
    <div id="device-selection">
        <h1>–í—ã–±–µ—Ä–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</h1>
        <div class="device-buttons">
            <button class="device-button" id="pc-button">–ö–æ–º–ø—å—é—Ç–µ—Ä / –ù–æ—É—Ç–±—É–∫</button>
            <button class="device-button" id="mobile-button">–¢–µ–ª–µ—Ñ–æ–Ω / –ü–ª–∞–Ω—à–µ—Ç</button>
        </div>
    </div>

    <div id="hud">
        <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
        <div>–û—á–∫–∏: <span id="score">0</span></div>
        <div>–ó–¥–æ—Ä–æ–≤—å–µ:</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo">–ü–∞—Ç—Ä–æ–Ω—ã: <span id="ammo-count">30</span> / <span id="max-ammo">30</span></div>
    </div>
    <div id="crosshair">+</div>
    <div id="hit-marker">√ó</div>
    <div id="reload-indicator">–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞...</div>
    <div id="game-over">
        <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
        <p>–í–∞—à —Å—á–µ—Ç: <span id="final-score">0</span></p>
        <button id="restart-button">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>
    <div id="level-up">
        <h2>–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
        <p>–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —É—Ä–æ–≤–µ–Ω—å <span id="new-level">2</span></p>
        <button id="next-level-button">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>

    <div id="mobile-controls">
        <div class="joystick-area">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="look-area" id="look-area"></div>
        <div class="action-buttons">
            <div class="action-button" id="shoot-button">üî´</div>
            <div class="action-button" id="jump-button">‚Üë</div>
            <div class="action-button" id="reload-button">‚Üª</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, player, controls;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let walls = [];
        let floor;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isShooting = false;
        let isCrouching = false;
        let isRunning = false;
        let health = 100;
        let score = 0;
        let level = 1;
        let ammo = 30;
        let maxAmmo = 30;
        let reloading = false;
        let gameOver = false;
        let levelCompleted = false;
        let isMobile = false;
        let joystickPosition = { x: 0, y: 0 };
        let touchLookPosition = { x: 0, y: 0 };
        let lastTouchLookPosition = { x: 0, y: 0 };
        let touchShootId = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let targetEnemy = null;
        let enemyHelpers = [];
        let skybox;
        let textures = {};
        let sounds = {};
        let particleSystems = [];
        
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const ENEMY_COUNT_BASE = 5;
        const LEVEL_SIZE_BASE = 100;
        const ENEMY_SPEED_BASE = 0.05;
        const PLAYER_SPEED = 0.15;
        const RUNNING_SPEED = 0.25;
        const GRAVITY = 0.005;
        const JUMP_FORCE = 0.2;
        const AUTO_AIM_DISTANCE = 20;
        const AUTO_AIM_ANGLE = 0.3;
        
        // –í—ã–±–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        document.getElementById('pc-button').addEventListener('click', function() {
            isMobile = false;
            document.getElementById('device-selection').style.display = 'none';
            init();
        });
        
        document.getElementById('mobile-button').addEventListener('click', function() {
            isMobile = true;
            document.getElementById('device-selection').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            init();
        });
        
        // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
        function preloadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            textures.ground = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.wall = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });
            
            textures.enemy = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ –∫—É–±–∏—á–µ—Å–∫–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è skybox
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            textures.skybox = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/skybox/px.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
                'https://threejs.org/examples/textures/cube/skybox/py.jpg',
                'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
                'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
            ]);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            preloadTextures();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.background = textures.skybox || new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ —Å –∞–Ω—Ç–∏–∞–ª–∏–∞—Å–∏–Ω–≥–æ–º –¥–ª—è –ª—É—á—à–µ–π –≥—Ä–∞—Ñ–∏–∫–∏
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio); // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –ú—è–≥–∫–∏–µ —Ç–µ–Ω–∏
            document.body.appendChild(renderer.domElement);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞ –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ (–∫–∞–º–µ—Ä–∞ + —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ)
            player = new THREE.Object3D();
            player.position.set(0, 2, 0);
            player.add(camera);
            scene.add(player);
            
            // –§–∏–∑–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
            player.velocity = new THREE.Vector3();
            player.direction = new THREE.Vector3();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–π–∫–∞—Å—Ç–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∫–æ–ª–ª–∏–∑–∏–π
            raycaster = new THREE.Raycaster();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
            createLevel();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            if (isMobile) {
                setupMobileControls();
            } else {
                setupPCControls();
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize, false);
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ü–ö
        function setupPCControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
            renderer.domElement.addEventListener('click', function() {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function setupMobileControls() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
            const joystickArea = document.querySelector('.joystick-area');
            const joystick = document.getElementById('joystick');
            
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetJoystick();
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±–ª–∞—Å—Ç–∏ –¥–ª—è –æ–±–∑–æ—Ä–∞
            const lookArea = document.getElementById('look-area');
            
            lookArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                lastTouchLookPosition.x = touch.clientX;
                lastTouchLookPosition.y = touch.clientY;
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
            });
            
            lookArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π
            document.getElementById('shoot-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                isShooting = true;
                shoot();
                touchShootId = setInterval(shoot, 200);
            });
            
            document.getElementById('shoot-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            });
            
            document.getElementById('jump-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (canJump) {
                    player.velocity.y = JUMP_FORCE;
                    canJump = false;
                }
            });
            
            document.getElementById('reload-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                reload();
            });
            
            function updateJoystickPosition(x, y) {
                const maxDistance = 40;
                const distance = Math.sqrt(x * x + y * y);
                
                if (distance > maxDistance) {
                    const ratio = maxDistance / distance;
                    x *= ratio;
                    y *= ratio;
                }
                
                joystick.style.transform = `translate(${x}px, ${y}px)`;
                
                // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
                joystickPosition.x = x / maxDistance;
                joystickPosition.y = y / maxDistance;
                
                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–∞–≥–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è
                moveForward = joystickPosition.y < -0.2;
                moveBackward = joystickPosition.y > 0.2;
                moveLeft = joystickPosition.x < -0.2;
                moveRight = joystickPosition.x > 0.2;
            }
            
            function resetJoystick() {
                joystick.style.transform = 'translate(0, 0)';
                joystickPosition.x = 0;
                joystickPosition.y = 0;
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function createLevel() {
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            enemies = [];
            bullets = [];
            enemyBullets = [];
            walls = [];
            enemyHelpers = [];
            particleSystems = [];
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –∏ –æ—Å–≤–µ—â–µ–Ω–∏—è –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(player);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ skybox
            if (textures.skybox) {
                scene.background = textures.skybox;
            }
            
            // –†–∞–∑–º–µ—Ä —É—Ä–æ–≤–Ω—è —Ä–∞—Å—Ç–µ—Ç —Å –∫–∞–∂–¥—ã–º —É—Ä–æ–≤–Ω–µ–º
            const levelSize = LEVEL_SIZE_BASE + (level * 20);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∞ —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
            const floorGeometry = new THREE.PlaneGeometry(levelSize, levelSize, 10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.ground,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            createWalls(levelSize);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createObstacles(levelSize);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            const enemyCount = ENEMY_COUNT_BASE + (level * 2);
            createEnemies(enemyCount, levelSize);
            
            // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ HUD
            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            updateHealthBar();
            
            // –°–±—Ä–æ—Å –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo = maxAmmo;
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω –≤–æ–∫—Ä—É–≥ —É—Ä–æ–≤–Ω—è
        function createWalls(size) {
            const wallHeight = 10;
            const wallThickness = 2;
            const halfSize = size / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.7,
                metalness: 0.2,
                bumpMap: textures.wall,
                bumpScale: 0.02
            });
            
            // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞
            const northWallGeometry = new THREE.BoxGeometry(size + wallThickness * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -halfSize - wallThickness / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);
            walls.push(northWall);
            
            // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
            const southWall = northWall.clone();
            southWall.position.z = halfSize + wallThickness / 2;
            scene.add(southWall);
            walls.push(southWall);
            
            // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, size);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(halfSize + wallThickness / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);
            walls.push(eastWall);
            
            // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
            const westWall = eastWall.clone();
            westWall.position.x = -halfSize - wallThickness / 2;
            scene.add(westWall);
            walls.push(westWall);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª—É—á–∞–π–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –Ω–∞ —É—Ä–æ–≤–Ω–µ
        function createObstacles(size) {
            const obstacleCount = 10 + level * 2;
            const halfSize = size / 2 - 5;
            
            for (let i = 0; i < obstacleCount; i++) {
                // –°–ª—É—á–∞–π–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                const width = Math.random() * 5 + 2;
                const height = Math.random() * 4 + 2;
                const depth = Math.random() * 5 + 2;
                
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                const x = Math.random() * (halfSize * 2) - halfSize;
                const z = Math.random() * (halfSize * 2) - halfSize;
                
                // –ù–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É
                if (Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
                const color = new THREE.Color(Math.random() * 0.5, Math.random() * 0.5, Math.random() * 0.5);
                
                // –°–ª—É—á–∞–π–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                let obstacleGeometry;
                const geometryType = Math.floor(Math.random() * 3);
                
                switch (geometryType) {
                    case 0:
                        obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
                        break;
                    case 1:
                        obstacleGeometry = new THREE.CylinderGeometry(width/2, width/2, height, 8);
                        break;
                    case 2:
                        obstacleGeometry = new THREE.TorusGeometry(width/2, depth/4, 16, 16);
                        break;
                }
                
                const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(x, height / 2, z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
                if (Math.random() > 0.5) {
                    obstacle.rotation.x = Math.random() * Math.PI;
                    obstacle.rotation.y = Math.random() * Math.PI;
                    obstacle.rotation.z = Math.random() * Math.PI;
                }
                
                scene.add(obstacle);
                walls.push(obstacle);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function createEnemies(count, size) {
            const halfSize = size / 2 - 10;
            
            for (let i = 0; i < count; i++) {
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                const x = Math.random() * (halfSize * 2) - halfSize;
                const z = Math.random() * (halfSize * 2) - halfSize;
                
                // –ù–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –≤—Ä–∞–≥–æ–≤ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É
                if (Math.abs(x) < 15 && Math.abs(z) < 15) continue;
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—Ä–∞–≥–∞
                const enemyGroup = new THREE.Group();
                
                // –¢–µ–ª–æ –≤—Ä–∞–≥–∞
                const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 1);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    roughness: 0.7,
                    metalness: 0.3,
                    map: textures.enemy
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                body.castShadow = true;
                body.receiveShadow = true;
                enemyGroup.add(body);
                
                // –ì–æ–ª–æ–≤–∞ –≤—Ä–∞–≥–∞
                const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff5555,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;
                head.castShadow = true;
                head.receiveShadow = true;
                enemyGroup.add(head);
                
                // –†—É–∫–∏ –≤—Ä–∞–≥–∞
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.9, 1, 0);
                leftArm.rotation.z = Math.PI / 2;
                leftArm.castShadow = true;
                leftArm.receiveShadow = true;
                enemyGroup.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.9, 1, 0);
                rightArm.rotation.z = -Math.PI / 2;
                rightArm.castShadow = true;
                rightArm.receiveShadow = true;
                enemyGroup.add(rightArm);
                
                // –ù–æ–≥–∏ –≤—Ä–∞–≥–∞
                const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.5, -0.5, 0);
                leftLeg.castShadow = true;
                leftLeg.receiveShadow = true;
                enemyGroup.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.5, -0.5, 0);
                rightLeg.castShadow = true;
                rightLeg.receiveShadow = true;
                enemyGroup.add(rightLeg);
                
                // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–∞–≥–∞
                enemyGroup.position.set(x, 0, z);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –≤—Ä–∞–≥–∞
                enemyGroup.health = 100;
                enemyGroup.speed = ENEMY_SPEED_BASE * (1 + level * 0.1);
                enemyGroup.lastShot = 0;
                enemyGroup.shootInterval = 2000 - level * 100; // –ò–Ω—Ç–µ—Ä–≤–∞–ª —Å—Ç—Ä–µ–ª—å–±—ã —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å —É—Ä–æ–≤–Ω–µ–º
                if (enemyGroup.shootInterval < 500) enemyGroup.shootInterval = 500; // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞ –¥–ª—è –≤—Ä–∞–≥–∞
                enemyGroup.collider = new THREE.Box3().setFromObject(enemyGroup);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ –Ω–∞ —Å—Ü–µ–Ω—É
                scene.add(enemyGroup);
                enemies.push(enemyGroup);
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ —Ö–µ–ª–ø–µ—Ä–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ø–∞–¥–∞–Ω–∏–π
                const helperGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
                const helperMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.0 // –ù–µ–≤–∏–¥–∏–º—ã–π
                });
                const helper = new THREE.Mesh(helperGeometry, helperMaterial);
                helper.position.copy(enemyGroup.position);
                helper.position.y = 1.5;
                helper.enemyRef = enemyGroup; // –°—Å—ã–ª–∫–∞ –Ω–∞ –≤—Ä–∞–≥–∞
                scene.add(helper);
                enemyHelpers.push(helper);
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à
        function onKeyDown(event) {
            if (gameOver || levelCompleted) return;
            
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) {
                        player.velocity.y = JUMP_FORCE;
                        canJump = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyC':
                    isCrouching = !isCrouching;
                    if (isCrouching) {
                        player.position.y = 1;
                        camera.position.y = 0;
                    } else {
                        player.position.y = 2;
                        camera.position.y = 0;
                    }
                    break;
                case 'KeyR':
                    reload();
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–ª–∞–≤–∏—à
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseDown(event) {
            if (gameOver || levelCompleted) return;
            
            if (event.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
                isShooting = true;
                shoot();
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseUp(event) {
            if (event.button === 0) {
                isShooting = false;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
        function lockChangeAlert() {
            if (document.pointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', updateCamera, false);
            } else {
                document.removeEventListener('mousemove', updateCamera, false);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏
        function updateCamera(event) {
            if (gameOver || levelCompleted) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            player.rotation.y -= movementX * 0.002;
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
            camera.rotation.x -= movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
        function findTargetEnemy() {
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            
            let closestEnemy = null;
            let closestAngle = AUTO_AIM_ANGLE;
            
            for (const helper of enemyHelpers) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Ä–∞–≥ –µ—â–µ –∂–∏–≤
                if (!helper.enemyRef || !scene.getObjectById(helper.enemyRef.id)) continue;
                
                // –í–µ–∫—Ç–æ—Ä –æ—Ç –∏–≥—Ä–æ–∫–∞ –∫ –≤—Ä–∞–≥—É
                const enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(helper.position, player.position).normalize();
                
                // –£–≥–æ–ª –º–µ–∂–¥—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≤–∑–≥–ª—è–¥–∞ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫ –≤—Ä–∞–≥—É
                const angle = lookDirection.angleTo(enemyDirection);
                
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –≤—Ä–∞–≥–∞
                const distance = player.position.distanceTo(helper.position);
                
                // –ï—Å–ª–∏ –≤—Ä–∞–≥ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —É–≥–ª–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –∏ –Ω–µ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (angle < closestAngle && distance < AUTO_AIM_DISTANCE) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (–Ω–µ—Ç –ª–∏ —Å—Ç–µ–Ω –º–µ–∂–¥—É –∏–≥—Ä–æ–∫–æ–º –∏ –≤—Ä–∞–≥–æ–º)
                    raycaster.set(player.position, enemyDirection);
                    const intersects = raycaster.intersectObjects(walls);
                    
                    if (intersects.length === 0 || 
                        intersects[0].distance > distance) {
                        closestEnemy = helper;
                        closestAngle = angle;
                    }
                }
            }
            
            return closestEnemy;
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞
        function shoot() {
            if (reloading || ammo <= 0) {
                if (ammo <= 0) reload();
                return;
            }
            
            // –ù–∞–π—Ç–∏ —Ü–µ–ª—å –¥–ª—è –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
            targetEnemy = findTargetEnemy();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏ –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            bullet.position.copy(player.position);
            bullet.position.y = camera.position.y;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏
            let direction = new THREE.Vector3();
            
            if (targetEnemy) {
                // –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–ª—å, —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–µ–µ
                direction.subVectors(targetEnemy.position, player.position).normalize();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
                direction.x += (Math.random() - 0.5) * 0.02;
                direction.y += (Math.random() - 0.5) * 0.02;
                direction.z += (Math.random() - 0.5) * 0.02;
                direction.normalize();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
                showHitMarker();
            } else {
                // –ò–Ω–∞—á–µ —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã
                camera.getWorldDirection(direction);
            }
            
            bullet.velocity = direction.multiplyScalar(1);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            bullets.push(bullet);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo--;
            document.getElementById('ammo-count').textContent = ammo;
            
            // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –¥–æ–±–∞–≤—å—Ç–µ –∑–≤—É–∫)
            // playSound('shoot');
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
        function createMuzzleFlash() {
            // –ü–æ–∑–∏—Ü–∏—è –≤—Å–ø—ã—à–∫–∏
            const muzzlePosition = new THREE.Vector3(0, 0, -1);
            muzzlePosition.applyQuaternion(camera.quaternion);
            muzzlePosition.add(camera.position);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –≤—Å–ø—ã—à–∫–∏
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –°–ª—É—á–∞–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ –≤—Å–ø—ã—à–∫–∏
                const x = muzzlePosition.x + (Math.random() - 0.5) * 0.2;
                const y = muzzlePosition.y + (Math.random() - 0.5) * 0.2;
                const z = muzzlePosition.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 10 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }
        
        // –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞
        function reload() {
            if (reloading || ammo === maxAmmo) return;
            
            reloading = true;
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
            document.getElementById('reload-indicator').style.display = 'block';
            
            setTimeout(() => {
                ammo = maxAmmo;
                document.getElementById('ammo-count').textContent = ammo;
                reloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
            }, 2000);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–æ—Å—ã –∑–¥–æ—Ä–æ–≤—å—è
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = health + '%';
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–¥–æ—Ä–æ–≤—å—è
            if (health > 60) {
                healthFill.style.backgroundColor = '#0f0';
            } else if (health > 30) {
                healthFill.style.backgroundColor = '#ff0';
            } else {
                healthFill.style.backgroundColor = '#f00';
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function createHitEffect(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –ø–æ–ø–∞–¥–∞–Ω–∏—è
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.1);
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 20 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤–æ –≤—Ä–∞–≥–∞
        function hitEnemy(enemy, bulletIndex) {
            enemy.health -= 25;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(bullets[bulletIndex].position.clone());
            
            if (enemy.health <= 0) {
                // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è
                createExplosion(enemy.position.clone());
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ —Å–æ —Å—Ü–µ–Ω—ã
                scene.remove(enemy);
                enemies.splice(enemies.indexOf(enemy), 1);
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (let i = 0; i < enemyHelpers.length; i++) {
                    if (enemyHelpers[i].enemyRef === enemy) {
                        scene.remove(enemyHelpers[i]);
                        enemyHelpers.splice(i, 1);
                        break;
                    }
                }
                
                // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞
                score += 100;
                document.getElementById('score').textContent = score;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
                if (enemies.length === 0) {
                    levelComplete();
                }
            }
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(bullets[bulletIndex]);
            bullets.splice(bulletIndex, 1);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
        function createExplosion(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –≤–∑—Ä—ã–≤–∞
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.2);
                velocities.push(velocity);
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –æ—Ç –∫—Ä–∞—Å–Ω–æ–≥–æ –¥–æ –∂–µ–ª—Ç–æ–≥–æ
                const color = new THREE.Color();
                color.setHSL(0.05 + Math.random() * 0.05, 1, 0.5 + Math.random() * 0.5);
                colors.push(color);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                colors: colors,
                life: 40 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
        function hitPlayer(bulletIndex) {
            health -= 10;
            updateHealthBar();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(enemyBullets[bulletIndex].position.clone());
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(enemyBullets[bulletIndex]);
            enemyBullets.splice(bulletIndex, 1);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
            if (health <= 0) {
                endGame();
            }
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function levelComplete() {
            levelCompleted = true;
            document.getElementById('new-level').textContent = level + 1;
            document.getElementById('level-up').style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                level++;
                document.getElementById('level-up').style.display = 'none';
                levelCompleted = false;
                createLevel();
            });
        }
        
        // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
            
            if (!isMobile) {
                document.exitPointerLock();
            }
            
            document.getElementById('restart-button').addEventListener('click', function() {
                document.getElementById('game-over').style.display = 'none';
                gameOver = false;
                health = 100;
                score = 0;
                level = 1;
                createLevel();
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
        function updateParticleSystems() {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π —á–∞—Å—Ç–∏—Ü
                const positions = system.particles.geometry.attributes.position.array;
                
                for (let j = 0; j < positions.length / 3; j++) {
                    positions[j * 3] += system.velocities[j].x;
                    positions[j * 3 + 1] += system.velocities[j].y;
                    positions[j * 3 + 2] += system.velocities[j].z;
                    
                    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                    system.velocities[j].y -= 0.001;
                }
                
                system.particles.geometry.attributes.position.needsUpdate = true;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                system.life--;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                system.particles.material.opacity = system.life / 40;
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                if (system.life <= 0) {
                    scene.remove(system.particles);
                    particleSystems.splice(i, 1);
                }
            }
        }
        
        // –û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            // –†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            deltaTime = clock.getDelta();
            
            if (!gameOver && !levelCompleted) {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
                updatePlayer();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
                updateEnemies();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
                updateBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
                updateEnemyBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
                updateParticleSystems();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                if (isMobile) {
                    updateMobileCamera();
                }
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ
                if (isShooting && !reloading && ammo > 0) {
                    shoot();
                }
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å—Ü–µ–Ω—ã
            renderer.render(scene, camera);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function updateMobileCamera() {
            if (touchLookPosition.x !== lastTouchLookPosition.x || 
                touchLookPosition.y !== lastTouchLookPosition.y) {
                
                const movementX = touchLookPosition.x - lastTouchLookPosition.x;
                const movementY = touchLookPosition.y - lastTouchLookPosition.y;
                
                player.rotation.y -= movementX * 0.01;
                
                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
                camera.rotation.x -= movementY * 0.01;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                
                lastTouchLookPosition.x = touchLookPosition.x;
                lastTouchLookPosition.y = touchLookPosition.y;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
        function updatePlayer() {
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            player.velocity.y -= GRAVITY;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ø–æ–ª–æ–º
            if (player.position.y < (isCrouching ? 1 : 2)) {
                player.position.y = isCrouching ? 1 : 2;
                player.velocity.y = 0;
                canJump = true;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
            player.position.y += player.velocity.y;
            
            // –†–∞—Å—á–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
            const speed = isRunning ? RUNNING_SPEED : PLAYER_SPEED;
            
            if (isMobile) {
                // –î–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞
                player.direction.z = -joystickPosition.y;
                player.direction.x = joystickPosition.x;
            } else {
                // –î–ª—è –ü–ö –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª–∞–≤–∏—à–∏
                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
            }
            
            player.direction.normalize();
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            if (player.direction.z !== 0) {
                player.velocity.z = player.direction.z * speed;
            }
            if (player.direction.x !== 0) {
                player.velocity.x = player.direction.x * speed;
            }
            
            // –ï—Å–ª–∏ –Ω–µ—Ç –¥–≤–∏–∂–µ–Ω–∏—è, –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ –∑–∞–º–µ–¥–ª—è–µ–º
            if (player.direction.z === 0) {
                player.velocity.z *= 0.9;
            }
            if (player.direction.x === 0) {
                player.velocity.x *= 0.9;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            const rotatedVelocity = player.velocity.clone();
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –ø–µ—Ä–µ–¥ –¥–≤–∏–∂–µ–Ω–∏–µ–º
            const nextPosition = player.position.clone();
            nextPosition.x += rotatedVelocity.x;
            nextPosition.z += rotatedVelocity.z;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
            let canMove = true;
            
            for (const wall of walls) {
                const playerBox = new THREE.Box3().setFromObject(
                    new THREE.Mesh(
                        new THREE.BoxGeometry(1, isCrouching ? 1 : 2, 1),
                        new THREE.MeshBasicMaterial()
                    )
                );
                playerBox.min.set(
                    nextPosition.x - 0.5,
                    nextPosition.y - (isCrouching ? 0.5 : 1),
                    nextPosition.z - 0.5
                );
                playerBox.max.set(
                    nextPosition.x + 0.5,
                    nextPosition.y + (isCrouching ? 0.5 : 1),
                    nextPosition.z + 0.5
                );
                
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                if (playerBox.intersectsBox(wallBox)) {
                    canMove = false;
                    break;
                }
            }
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
            if (canMove) {
                player.position.x += rotatedVelocity.x;
                player.position.z += rotatedVelocity.z;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function updateEnemies() {
            const now = Date.now();
            
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === enemy) {
                        helper.position.copy(enemy.position);
                        helper.position.y = 1.5;
                        break;
                    }
                }
                
                // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–∞
                raycaster.set(enemy.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // –ï—Å–ª–∏ –º–µ–∂–¥—É –≤—Ä–∞–≥–æ–º –∏ –∏–≥—Ä–æ–∫–æ–º –Ω–µ—Ç —Å—Ç–µ–Ω
                if (intersects.length === 0 || 
                    intersects[0].distance > enemy.position.distanceTo(player.position)) {
                    
                    // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                    const newPosition = enemy.position.clone();
                    newPosition.x += direction.x * enemy.speed;
                    newPosition.z += direction.z * enemy.speed;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
                    let canMove = true;
                    
                    for (const wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(
                            new THREE.Mesh(
                                new THREE.BoxGeometry(1.5, 3, 1.5),
                                new THREE.MeshBasicMaterial()
                            )
                        );
                        enemyBox.min.set(
                            newPosition.x - 0.75,
                            newPosition.y - 1.5,
                            newPosition.z - 0.75
                        );
                        enemyBox.max.set(
                            newPosition.x + 0.75,
                            newPosition.y + 1.5,
                            newPosition.z + 0.75
                        );
                        
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (enemyBox.intersectsBox(wallBox)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
                    if (canMove) {
                        enemy.position.copy(newPosition);
                    }
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –≤—Ä–∞–≥–∞ –∫ –∏–≥—Ä–æ–∫—É
                    enemy.lookAt(player.position);
                    
                    // –°—Ç—Ä–µ–ª—å–±–∞ –≤ –∏–≥—Ä–æ–∫–∞
                    if (now - enemy.lastShot > enemy.shootInterval) {
                        enemyShoot(enemy);
                        enemy.lastShot = now;
                    }
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞–≥–∞ (–ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
                enemy.position.y = Math.sin(now * 0.003 + i) * 0.1;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞
                enemy.collider = new THREE.Box3().setFromObject(enemy);
            }
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞ –≤—Ä–∞–≥–∞
        function enemyShoot(enemy) {
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏
            bullet.position.copy(enemy.position);
            bullet.position.y = 1.5;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–±–æ–ª—å—à–æ–≥–æ —Ä–∞–∑–±—Ä–æ—Å–∞
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(0.7);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            enemyBullets.push(bullet);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –≤—Ä–∞–≥–∞–º–∏
                for (let j = 0; j < enemyHelpers.length; j++) {
                    const helper = enemyHelpers[j];
                    
                    const bulletBox = new THREE.Box3().setFromObject(bullet);
                    const enemyBox = new THREE.Box3().setFromObject(helper);
                    
                    if (bulletBox.intersectsBox(enemyBox)) {
                        hitEnemy(helper.enemyRef, i);
                        // –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞, —Ç–∞–∫ –∫–∞–∫ –ø—É–ª—è —É–∂–µ —É–¥–∞–ª–µ–Ω–∞
                        break;
                    }
                }
                
                // –ï—Å–ª–∏ –ø—É–ª—è –≤—Å–µ –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                if (i < bullets.length) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                    for (const wall of walls) {
                        const bulletBox = new THREE.Box3().setFromObject(bullet);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (bulletBox.intersectsBox(wallBox)) {
                            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                            createHitEffect(bullet.position.clone());
                            
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < bullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –∏–≥—Ä–æ–∫–æ–º
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (bulletBox.intersectsBox(playerBox)) {
                    hitPlayer(i);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    
                    if (bulletBox.intersectsBox(wallBox)) {
                        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                        createHitEffect(bullet.position.clone());
                        
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < enemyBullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
